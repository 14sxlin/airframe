<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Airframe RPC · Airframe</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Airframe RPC is a framework for building RPC services by using Scala as a unified RPC interface between servers and clients."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Airframe RPC · Airframe"/><meta property="og:type" content="website"/><meta property="og:url" content="https://wvlet.org/airframe/"/><meta property="og:description" content="Airframe RPC is a framework for building RPC services by using Scala as a unified RPC interface between servers and clients."/><meta property="og:image" content="https://wvlet.org/airframe/img/poster.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://wvlet.org/airframe/img/poster.png"/><link rel="shortcut icon" href="/airframe/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://wvlet.org/airframe/blog/atom.xml" title="Airframe Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://wvlet.org/airframe/blog/feed.xml" title="Airframe Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-98364158-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/airframe/js/scrollSpy.js"></script><link rel="stylesheet" href="/airframe/css/main.css"/><script src="/airframe/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/airframe/"><img class="logo" src="/airframe/img/favicon.ico" alt="Airframe"/><h2 class="headerTitleWithLogo">Airframe</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/airframe/docs/" target="_self">Docs</a></li><li class=""><a href="/airframe/blog/" target="_self">Blog</a></li><li class=""><a href="/airframe/docs/release-notes" target="_self">Release Notes</a></li><li class=""><a href="https://github.com/wvlet/airframe/" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Framework</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Resources</h3><ul class=""><li class="navListItem"><a class="navItem" href="/airframe/docs/">Overview</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/articles">Articles</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/release-notes">Release Notes</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/logos">Logos</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework</h3><ul class=""><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe">airframe-di: Dependency Injection</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/airframe/docs/airframe-rpc">Airframe RPC</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-http">airframe-http: Creating REST Service</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airspec">AirSpec: Testing Framework</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Core Modules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-codec">airframe-codec: Schema-On-Read Object Serializer</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-config">airframe-config: Application Config Flow</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-control">airframe-control: Retry/Rate Control</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-log">airframe-log: Application Logger</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-metrics">airframe-metrics: Human-Friendly Measures for Time and Data Size</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-surface">airframe-surface: Object Shape Inspector</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Utilities</h3><ul class=""><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-benchmark">airframe-benchmark: JMH Benchmark</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-canvas">airframe-canvas: Off-Heap Memory Manager</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-fluentd">airframe-fluentd: Fluentd Logger</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-http-recorder">airframe-http-recorder: Web Request/Response Recorder</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-jdbc">airframe-jdbc: JDBC Connection Pool</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-jmx">airframe-jmx: JMX Application Monitor</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-json">airframe-json: Pure-Scala JSON Parser</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-launcher">airframe-launcher: Command-Line Program Launcher</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-msgpack">airframe-msgpack: Pure-Scala MessagePack Parser</a></li><li class="navListItem"><a class="navItem" href="/airframe/docs/airframe-sql">airframe-sql: SQL Parser</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Airframe RPC</h1></header><article><div><span><p>Airframe RPC is a framework for building RPC services by using Scala as a unified RPC interface between servers and clients.</p>
<p><img src="../img/airframe-rpc/rpc-overview.png" alt="overview"></p>
<h2><a class="anchor" aria-hidden="true" id="why-airframe-rpc"></a><a href="#why-airframe-rpc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Airframe RPC?</h2>
<p>Airframe RPC enables calling Scala methods at remote servers. You don’t need to worry about how to encode your data into JSON, nor how to define HTTP REST endpoints. Airframe RPC abstracts away these details; the framework generates code for serializing your data objects into JSON or MessagePack and calls appropriate HTTP endpoints on your behalf.</p>
<p>While <a href="https://grpc.io/">gRPC</a> has been a popular approach for building RPC services, it's built around <a href="https://developers.google.com/protocol-buffers/docs/overview">Protobuf</a> technology for defining data structures and RPC methods. This means, you and your collaborators need to use Protobuf ecosystem almost for everything to enjoy the benefits of gRPC. And also, gRPC heavily uses HTTP/2 features, some of them are not supported in web browsers, so if you need to write web applications using gRPC, an additional proxy like <a href="https://grpc.io/docs/languages/web/basics/">gRPC-Web</a> is required.</p>
<p>In 2020, <a href="https://www.scala-js.org/news/2020/02/25/announcing-scalajs-1.0.0/">Scala.js, which can compile Scala code into JavaScript, finally became 1.0.0 after 7 years of development</a>. This has paved a way for using Scala both for server (Scala JVM) and client (Scala.js) implementations. We explored an approach for using Scala's functional interfaces as RPC endpoint definitions, and successfully created Airframe RPC on top of <a href="/airframe/docs/">technology stack of 20+ Airframe modules</a>.</p>
<p>Although Airframe RPC is a relatively new project started at March 2020 inside <a href="https://www.treasuredata.com/">Arm Treasure Data</a>, this project has proved various advantages. For example:</p>
<ul>
<li><strong>Free from REST</strong>. We can just use Scala's functional interface for defining servers. <a href="https://cloud.google.com/apis/design">Google's REST API Design Guide</a> has been useful resources for defining clear REST API endpoints, but we've found using programming language's native interface is much easier.</li>
<li><strong>No more web-framework wars</strong>. In Scala, there are many web frameworks, such as <a href="https://github.com/twitter/finatra">Finatra</a>, <a href="https://github.com/finagle/finch">Finch</a>, <a href="https://doc.akka.io/docs/akka-http/current/index.html">Akka HTTP</a>, and our own <a href="/airframe/docs/airframe-http">airframe-http</a>, etc. Each of them has its own pros and cons, and choosing one of them has been a hard choice for us. Now, we can just start from Airframe RPC using plain Scala interfaces. If necessary, we can use airframe-http for adding custom HTTP endpoints.</li>
<li><strong>Seamless integration with Scala.js</strong>. Writing web browser applications in JavaScript that interact with servers is not easy. You may need to learn about the existing frameworks like <a href="https://https://reactjs.org/">React.js</a>, <a href="https://vuejs.org">Vue.js</a>, and a lot of techniques for using them. By using Scala both for server and client code, an engineer just joined the company could write an RPC application using Scala and Scala.js in a few days.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="airframe-rpc-overview"></a><a href="#airframe-rpc-overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Airframe RPC: Overview</h2>
<p>For using Airframe RPC, first, define your RPC service interface using regular Scala functions by adding <code>@RPC</code> annotation.
All public methods in this class will be your RPC endpoints. For the method arguments and return types, you can use arbitrary types (See <a href="#object-serialization">Object Serialization</a> for the list of available types). To pass complex messages, you can use case classes.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">package</span> hello.api.v1;
<span class="hljs-keyword">import</span> wvlet.airframe.http._

<span class="hljs-comment">// A model classe. This will be serialized into JSON or MessagePack </span>
case <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(id:<span class="hljs-built_in">Int</span>, name:String)

<span class="hljs-comment">// RPC interface definition </span>
<span class="hljs-meta">@RPC</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MyService</span> </span>{ 
  def hello(person:Person): String 
}
</code></pre>
<p>Next, implement this service interface in Scala:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">package</span> hello.api.v1
<span class="hljs-keyword">import</span> wvlet.airframe.http._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyService</span> </span>{
  <span class="hljs-function">override def <span class="hljs-title">hello</span><span class="hljs-params">(person:Person)</span>: String </span>= s<span class="hljs-string">"Hello ${person.name} (id=${person.id})!"</span>
}
</code></pre>
<p>To start an RPC web server, Airfarme RPC provides Finagle-based web server implementation.
The following code starts an RPC web server at <code>http://localhost:8080/</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Create a Router</span>
val router = Router.add[MyServiceImpl]
  
<span class="hljs-comment">// Starting a new RPC server.</span>
Finagle
  .server
  .withRouter(router)
  .withPort(<span class="hljs-number">8080</span>)
  .start { <span class="hljs-function"><span class="hljs-params">server</span> =&gt;</span>
    server.waitForTermination
  }
</code></pre>
<p>To access the RPC server, we need to generate an RPC client from the RPC interface definition.
We can use an RPC client <code>hello.api.v1.ServiceSyncClient</code>  generated by <a href="#sbt-airframe-plugin">sbt-airframe</a>, which
reads an RPC interface code and generates HTTP client code for calling RPC methods.</p>
<p>Now, you are ready to call remote Scala methods:</p>
<pre><code class="hljs css language-scala">import hello.api.v1._

// <span class="hljs-keyword">Create</span> an RPC <span class="hljs-keyword">client</span> 
val <span class="hljs-keyword">client</span> = <span class="hljs-keyword">new</span> ServiceSyncClient(Http.client.newSyncClient(<span class="hljs-string">"localhost:8080"</span>))

// Your <span class="hljs-keyword">first</span> RPC <span class="hljs-keyword">call</span>!
client.myService.hello(Person(<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>, <span class="hljs-keyword">name</span>=<span class="hljs-string">"leo"</span>)) // <span class="hljs-string">"Hello leo (id=1)!"</span>
</code></pre>
<p>That’s it! Now you can call remote Scala methods as if they were regular Scala functions. Airframe RPC also supports asynchronous clients using Future.</p>
<h2><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>The basic flow of using Airframe RPC is as follows:</p>
<ol>
<li>Define RPC interfaces with <code>@RPC</code> annotation</li>
<li>Implement the RPC interfaces in Scala</li>
<li>Create <code>wvlet.airframe.http.Router</code> by adding the RPC interface implementation classes.</li>
<li>Generate RPC client code with sbt-airfrme plugin</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="basic-project-structure"></a><a href="#basic-project-structure" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basic Project Structure</h3>
<p>Here is an example build configurations for using Airframe RPC with Scala and Scala.js.</p>
<p><a href="https://search.maven.org/search?q=g:%22org.wvlet.airframe%22%20AND%20a:%22airframe_2.12%22"><img src="https://img.shields.io/maven-central/v/org.wvlet.airframe/airframe_2.12.svg?label=maven%20central" alt="maven central"></a></p>
<p><strong>project/plugins.sbt</strong></p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// For RPC client generation</span>
<span class="hljs-selector-tag">addSbtPlugin</span>(<span class="hljs-string">"org.wvlet.airframe"</span> % <span class="hljs-string">"sbt-airframe"</span> % <span class="hljs-string">"(version)"</span>)

<span class="hljs-comment">// For Scala.js</span>
<span class="hljs-selector-tag">addSbtPlugin</span>(<span class="hljs-string">"org.scala-js"</span>       % <span class="hljs-string">"sbt-scalajs"</span>              % <span class="hljs-string">"1.1.0"</span>)
<span class="hljs-selector-tag">addSbtPlugin</span>(<span class="hljs-string">"org.portable-scala"</span> % <span class="hljs-string">"sbt-scalajs-crossproject"</span> % <span class="hljs-string">"1.0.0"</span>)
</code></pre>
<p><strong>build.sbt</strong></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> AIRFRAME_VERSION=<span class="hljs-string">"(version)"</span>

<span class="hljs-comment">// Common build settings</span>
<span class="hljs-keyword">val</span> buildSettings = Seq( 
  organization := <span class="hljs-string">"(your organization)"</span>,
  scalaVersion := <span class="hljs-string">"2.12.10"</span>,
  <span class="hljs-comment">// Add our own settings</span>
)

<span class="hljs-comment">// RPC API definition. This project should contain only RPC interfaces</span>
lazy <span class="hljs-keyword">val</span> api =
  crossProject(JSPlatform, JVMPlatform)
    .crossType(CrossType.Pure)
    .<span class="hljs-keyword">in</span>(file(<span class="hljs-string">"myapp-api"</span>))
    .setttings(
       buildSettings, 
       <span class="hljs-string">"org.wvlet.airframe"</span> %%% <span class="hljs-string">"airframe-http"</span> % AIRFRAME_VERSION
     )

lazy <span class="hljs-keyword">val</span> apiJVM = api.jvm
lazy <span class="hljs-keyword">val</span> apiJS = api.js

<span class="hljs-comment">// RPC server project</span>
lazy <span class="hljs-keyword">val</span> server =
  project
    .<span class="hljs-keyword">in</span>(file(<span class="hljs-string">"myapp-server"</span>))
    .settings(
      buildSettings, 
      libraryDependencies ++= Seq(
        <span class="hljs-string">"org.wvlet.airframe"</span> %% <span class="hljs-string">"airframe-http-finagle"</span> % AIRFRAME_VERSION
      )
    )
    .dependsOn(apiJVM)

<span class="hljs-comment">// RPC client project </span>
lazy <span class="hljs-keyword">val</span> client =
  project
    .<span class="hljs-keyword">in</span>(file(<span class="hljs-string">"myapp-client"</span>))
    .enablePlugins(AiframeHttpPlugin)
    .settings(
      buildSettings, 
      <span class="hljs-comment">// Generates both ServiceSyncClient and ServiceClient (async)</span>
      airframeHttpClients := Seq(<span class="hljs-string">"myapp.app.v1:sync"</span>, <span class="hljs-string">"myapp.app.v1:async"</span>),
      <span class="hljs-comment">// Enable debug logging of sbt-airframe</span>
      airframeHttpGeneratorOption := <span class="hljs-string">"-l debug"</span>,
      libraryDependencies ++= Seq(
        <span class="hljs-string">"org.wvlet.airframe"</span> %% <span class="hljs-string">"airframe-http-finagle"</span> % AIRFRAME_VERSION
      )
    )
    .dependsOn(apiJVM)

<span class="hljs-comment">// Scala.js UI using RPC </span>
lazy <span class="hljs-keyword">val</span> ui =
  project
    .<span class="hljs-keyword">in</span>(file(<span class="hljs-string">"myapp-ui"</span>))
    .enablePlugins(ScalaJSPlugin, AirframeHttpPlugin)
    .settings(
      buildSettings
      <span class="hljs-comment">// sbt-airframe generates Scala.js HTTP client: ServiceJSClient with this setting:</span>
      airframeHttpClients := Seq(<span class="hljs-string">"myapp.app.v1:scalajs"</span>),
      <span class="hljs-comment">// Enable debug logging of sbt-airframe</span>
      airframeHttpGeneratorOption := <span class="hljs-string">"-l debug"</span>
    )
    .dependsOn(apiJS)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="sbt-airframe-plugin"></a><a href="#sbt-airframe-plugin" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sbt-airframe plugin</h3>
<p>sbt-airframe plugins supports generating HTTP clients for making RPC calls. sbt-airframe supports generating async, sync, or Scala.js HTTP clients.</p>
<p><a href="https://search.maven.org/search?q=g:%22org.wvlet.airframe%22%20AND%20a:%22airframe_2.12%22"><img src="https://img.shields.io/maven-central/v/org.wvlet.airframe/airframe_2.12.svg?label=maven%20central" alt="maven central"></a></p>
<p>Add the following plugin settings:</p>
<p><strong>project/plugins.sbt</strong></p>
<pre><code class="hljs css language-scala"><span class="hljs-selector-tag">addSbtPlugin</span>(<span class="hljs-string">"org.wvlet.airframe"</span> % <span class="hljs-string">"sbt-airframe"</span> % <span class="hljs-string">"(version)"</span>)
</code></pre>
<p>To generate HTTP clients, add <code>airframeHttpClients</code> setting to your <code>build.sbt</code>. You need to specify which API package to use for generating RPC clients. The format is <code>&lt;RPC package name&gt;:&lt;client type&gt;(:&lt;target package name&gt;)?</code>. For example:</p>
<p><strong>build.sbt</strong></p>
<pre><code class="hljs css language-scala">enablePlugins(AiframeHttpPlugin)

airframeHttpClients := Se<span class="hljs-string">q("hello.api.v1:sync")</span>
</code></pre>
<p>Supported client types are:</p>
<ul>
<li><strong>sync</strong>: Create a sync HTTP client (ServiceSyncClient) for Scala (JVM)</li>
<li><strong>async</strong>: Create an async HTTP client (ServiceClient) for Scala (JVM) using Future abstraction (<code>F</code>). The <code>F</code> can be <code>scala.concurrent.Future</code> or twitter-util's Future.</li>
<li><strong>scalajs</strong>:  Create an RPC client (ServiceClientJS)</li>
</ul>
<p>To support other types of clients, see the examples of <a href="https://github.com/wvlet/airframe/blob/master/airframe-http/.jvm/src/main/scala/wvlet/airframe/http/codegen/client/ScalaHttpClient.scala">HTTP code generators</a>. This code reads a Router definition of RPC interfaces, and generate client code for calling RPC endpoints. Currently, we only supports generating HTTP clients for Scala. In near future, we would like to add Open API spec generator so that many programming languages can be used with Airframe RPC.</p>
<p>The generated client code can be found in <code>target/scala-2.12/src_managed/(api package)/</code> folder.</p>
<h4><a class="anchor" aria-hidden="true" id="sbt-airframe-commands"></a><a href="#sbt-airframe-commands" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sbt-airframe commands</h4>
<pre><code class="hljs css language-scala"><span class="hljs-meta">&gt;</span><span class="bash"> airframeHttpReload           <span class="hljs-comment"># Regenerate the generated client code. Use this if RPC interface has changed   </span></span>
<span class="hljs-meta">&gt;</span><span class="bash"> airframeHttpGenerateClients  <span class="hljs-comment"># Generating RPC clients manually</span></span>
<span class="hljs-meta">&gt;</span><span class="bash"> airframeHttpClean            <span class="hljs-comment"># Clean the generated code</span></span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="open-api"></a><a href="#open-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Open API</h3>
<p>sbt-airframe plugin also supports generating <a href="http://spec.openapis.org/oas/v3.0.3">Open API</a> specification from Airframe RPC interfaces.
To generate OpenAPI spec from RPC definition, add <code>airframeHttpOpenAPIPackages</code> configuration to your build.sbt:</p>
<pre><code class="hljs css language-scala">// [Required] RPC packages to <span class="hljs-keyword">use</span> <span class="hljs-keyword">for</span> generating <span class="hljs-keyword">Open</span> API specification
airframeHttpOpenAPIPackages := Seq(<span class="hljs-string">"hello.api"</span>)
// [Optional] Specify target <span class="hljs-keyword">directory</span> <span class="hljs-keyword">to</span> generate openapi.yaml. The <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> target <span class="hljs-keyword">directory</span>
airframeHttpOpenAPITargetDir := target.value
// [Optional] Additional configurations (e.g., title, <span class="hljs-keyword">version</span>, etc.)
airframeHttpOpenAPIConfig := OpenAPIConfig(
  title = <span class="hljs-string">"My API"</span>,      // <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">project</span> <span class="hljs-keyword">name</span>
  <span class="hljs-keyword">version</span> = <span class="hljs-string">"1.0.0"</span>,     // <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">project</span> <span class="hljs-keyword">version</span>,
  <span class="hljs-keyword">format</span> = <span class="hljs-string">"yaml"</span>,       // yaml (<span class="hljs-keyword">default</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">json</span>
  filePrefix = <span class="hljs-string">"openapi"</span> // <span class="hljs-keyword">Output</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">name</span>: (filePrefix).(<span class="hljs-keyword">format</span>)  
)
</code></pre>
<p>With this configuration, Open API spec will be generated when running <code>package</code> task:</p>
<pre><code class="hljs css language-scala">&gt; <span class="hljs-keyword">package</span>
</code></pre>
<p>It will generate <code>target/openapi.yaml</code> file.</p>
<h3><a class="anchor" aria-hidden="true" id="rpc-logging"></a><a href="#rpc-logging" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC Logging</h3>
<p>Airframe RPC stores HTTP access logs to <code>log/http-access.json</code> by default. This json logs contains
HTTP request related parameters and RPC-specific fields described below:</p>
<ul>
<li><strong>rpc_interface</strong>: RPC interface class name</li>
<li><strong>rpc_class</strong>: The atual RPC implementation class name</li>
<li><strong>rpc_method</strong>: The RPC method name</li>
<li><strong>rpc_args</strong>: The RPC call argument parameters described in JSON</li>
</ul>
<p>These parameters can be used for debugging your RPC requests.</p>
<p>See also <a href="/airframe/docs/airframe-http#access-logs">airframe-http: Access Logs</a> for more details.</p>
<h3><a class="anchor" aria-hidden="true" id="rpc-filters"></a><a href="#rpc-filters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC Filters</h3>
<p>Airframe RPC can chain arbitrary HTTP request filters before processing HTTP requests.
Most typical use cases would be adding an authentication filter for RPC calls:</p>
<pre><code class="hljs css language-scala">import wvlet.airframe.http._
import wvlet.ariframe.http.finagle._

object AuthFilter extends FinagleFilter <span class="hljs-keyword">with</span> LogSupport {
  <span class="hljs-keyword">def</span> <span class="hljs-keyword">apply</span>(request: Request, <span class="hljs-keyword">context</span>: <span class="hljs-keyword">Context</span>): Future[Response] = {
    val auth = request.authorization
    <span class="hljs-keyword">if</span>(isValidAuth(auth)) {
      // <span class="hljs-keyword">Call</span> the <span class="hljs-keyword">next</span> filter <span class="hljs-keyword">chain</span>
      <span class="hljs-keyword">context</span>(request)
    }
    <span class="hljs-keyword">else</span> {
      // <span class="hljs-keyword">Reject</span> the request
      Future.value(Response(Version.Http11, Status.Forbidden))
    }
  }
}
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Router for RPC</span>
val rpcRouter = Router.<span class="hljs-keyword">add</span>[MyApp] 

<span class="hljs-comment">// Add a filter before processing RPC requests</span>
val router = Router
  .<span class="hljs-keyword">add</span>(AuthFilter)
  .andThen(rpcRouterr)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="di-integration"></a><a href="#di-integration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DI Integration</h3>
<p>Airframe RPC natively supports <a href="/airframe/docs/airframe">Airframe DI</a> for dependency injection so that you can inject
necessary components for running your web service using <code>bind[X]</code> syntax or constructor injection.
DI is useful when building web applications requiring many components and if you need to decouple
component implementations from the service implementations. Airframe DI also supports switching component implementations
between production and tests for the convenience of module tests.</p>
<p>Here is an example of using Airframe DI for starting an RPC server:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> wvlet.airframe._

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MyAPIImpl</span> <span class="hljs-title">extends</span> <span class="hljs-title">MyAPI</span> </span>{
  <span class="hljs-comment">// Inject your component</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> myService = bind[MyService]
  
  <span class="hljs-keyword">override</span> def hello(...) = ...
}

<span class="hljs-keyword">val</span> router = Router.add[MyAPIImpl]

<span class="hljs-comment">// Define the component implementation to use</span>
<span class="hljs-keyword">val</span> design = newDesign
  .bind[MyService].toInstance(new MyServiceImpl(...))
  .add(Finagle.server.withRouter(router).design)

<span class="hljs-comment">// Launch a Finagle Server</span>
design.build[FinagleServer] { server =&gt;
  server.waitForTermination
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="object-serialization"></a><a href="#object-serialization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object Serialization</h3>
<p>Airframe <code>@RPC</code> interface supports almost all commonly used data types in Scala (and Scala.js). Note that some Java-specific classes (e.g., ZonedDateTime) is not supported in Scala.js.</p>
<p>Here is the list of available data types:</p>
<ul>
<li>case classes whose parameter types (including generic types) are described in this list.</li>
<li>Primitive types (Int, Long, String, Double, Float, Boolean, etc)</li>
<li>java.util.UUID</li>
<li>java.time.Instant (recommended because it can be used for Scala.js too)
<ul>
<li>(JVM only) ZonedDataTime, java.util.Date. These types cannot be used in Scala.js.</li>
</ul></li>
<li>Collection types: Seq, IndexedSeq, List, Set, Array, Map, Tuple (up to 21 parameters), Option, Either.</li>
<li>Exception, Throwable
<ul>
<li>Exception types will be serialized as GenericException for safety.</li>
</ul></li>
<li><a href="/airframe/docs/airframe-metrics">airframe-metrics</a> types: ElapsedTime, DataSize, Count, etc.</li>
<li>Raw Json, JSONValue, MsgPack values.</li>
<li>Enum-like case object class, which has <code>object X { def unapply(s:String): Option[X] }</code> definition. String representation of enum-like classes will be used. Scala's native Enumeration classes are not supported.</li>
</ul>
<p>Airframe RPC internally uses <a href="/airframe/docs/airframe-codec">schema-on-read functionality of airframe-codec</a> for serializing messages between server and clients. Even if the data type is slightly different from the target type, for example, if the input data is &quot;100&quot;, but the target type is Int, the input String &quot;100&quot; will be translated into an Int value <code>100</code> automatically.</p>
<h3><a class="anchor" aria-hidden="true" id="receiving-raw-http-responses"></a><a href="#receiving-raw-http-responses" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Receiving Raw HTTP Responses</h3>
<p>If you need to manage HTTP request specific parameters (e.g., HTTP headers), you can add request object to the RPC arguments.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> wvlet.airframe.http._
<span class="hljs-keyword">import</span> wvlet.airframe.http.HttpMessage.{Request, Respone}

<span class="hljs-meta">@RPC</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MyAPI</span> </span>{
  def rpc1(p1:String, p2:<span class="hljs-built_in">Int</span>, request:Request): Response
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="other-tips"></a><a href="#other-tips" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other Tips</h3>
<p>Airframe RPC is built on top of Airframe HTTP framework. See <a href="/airframe/docs/airframe-http">Airframe HTTP documentation</a> for the other features and advanced configurations.</p>
<h2><a class="anchor" aria-hidden="true" id="airframe-grpc"></a><a href="#airframe-grpc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Airframe gRPC</h2>
<p><em>(This is an experimental feature available since Airframe 20.8.0)</em></p>
<p>Airframe gRPC is a gRPC and HTTP2-based implementation of Airframe RPC, which can make thousands of RPC calls per second. With Airframe gRPC:</p>
<ul>
<li>No Protobuf definition is required. You can use plain Scala and case classes to define gRPC service.</li>
<li>Roadmap
<ul>
<li>[x] Create a gRPC server from Airframe RPC router</li>
<li>[ ] Generate gRPC client stub with sbt-airframe plugin.</li>
<li>[ ] Support client, server-side, and bidirectional streaming</li>
<li>[ ] Add a gRPC server proxy with airframe-http-finagle for supporting HTTP1</li>
</ul></li>
</ul>
<p><strong>build.sbt</strong></p>
<pre><code class="hljs css language-scala"><span class="hljs-string">"org.wvlet.airframe"</span> %% <span class="hljs-string">"airframe-http-grpc"</span> % AIRFRAME_VERSION
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="starting-airframe-grpc-server"></a><a href="#starting-airframe-grpc-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Starting Airframe gRPC Server</h3>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> wvlet.airframe.http.Router
<span class="hljs-keyword">import</span> wvlet.airframe.http.grpc.Grpc

<span class="hljs-comment">// Create a Router definition in the same manner with Airframe RPC</span>
<span class="hljs-keyword">val</span> router = Router.add[MyApiImpl]

<span class="hljs-keyword">val</span> grpcServerDesign = Grpc.server
  .withRouter(router)
  .withPort(<span class="hljs-number">8080</span>)
  .design

grpcServerDesign.build[GrpcServer] { server =&gt;
  <span class="hljs-comment">// gRPC server (based on Netty) starts at localhost:8080</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="rpc-internals"></a><a href="#rpc-internals" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC Internals</h2>
<p>(<em>This section describes the internals of Airframe RPC protocol. Just for using Airframe RPC, you can skip this section.</em>)</p>
<h3><a class="anchor" aria-hidden="true" id="rpc-protocol"></a><a href="#rpc-protocol" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RPC Protocol</h3>
<p>HTTP Requests and Responses</p>
<p>Airframe RPC maps function calls to HTTP POST requests. Let's see how RPC calls will be translted into HTTP requests using the following RPC interface example:</p>
<pre><code class="hljs css language-scala">package hello.api.v1
@RPC
trait MyService { 
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-symbol">request:</span>HelloRequest)</span></span>: HelloResponse 
}

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloRequest</span>(<span class="hljs-title">name</span>:<span class="hljs-title">String</span>)</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloResponse</span>(<span class="hljs-title">message</span>:<span class="hljs-title">String</span>) </span>
</code></pre>
<ul>
<li><strong>Method</strong>: POST</li>
<li><strong>Path</strong>: <code>/(package name).(RPC interface name)/(method name)</code>
<ul>
<li>ex. <code>POST /hello.api.v1.MyService/hello</code></li>
</ul></li>
<li><strong>Content-Type</strong>: <code>application/json</code> (default) or <code>application/x-msgpack</code></li>
<li><strong>Request body</strong>: JSON (or MessagePack) representation of the method arguments. Each method parameter names and arguments need to be a key-value pair in the JSON object.
<ul>
<li>For an RPC method <code>def m(p1:T1, p2:T2, ...)</code>, the request body will have the structrure of <code>{&quot;p1&quot;:(json representation of T1), &quot;p2&quot;:(json representation of T2}, ...}</code>. For example, the request to the above <code>hello(request:HelloRequest)</code> method will require the following JSON body:</li>
</ul></li>
</ul>
<pre><code class="hljs css language-json">{<span class="hljs-attr">"request"</span>:{<span class="hljs-attr">"name"</span>:<span class="hljs-string">"leo"</span>}}
</code></pre>
<ul>
<li><strong>Accept</strong>: &quot;application/json&quot; (default) or &quot;application/x-msgpack&quot;</li>
<li><strong>Response body</strong>: JSON (or MessagePack) representation of the method return type:</li>
</ul>
<pre><code class="hljs css language-json">{<span class="hljs-attr">"message"</span>:<span class="hljs-string">"..."</span>}
</code></pre>
<p>-<strong>Http Status</strong></p>
<ul>
<li>200 (Ok) for successful responses.</li>
<li>400 (Bad Request) if some request parameters are invalid.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/airframe/docs/airframe"><span class="arrow-prev">← </span><span>airframe-di: Dependency Injection</span></a><a class="docs-next button" href="/airframe/docs/airframe-http"><span>airframe-http: Creating REST Service</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#why-airframe-rpc">Why Airframe RPC?</a></li><li><a href="#airframe-rpc-overview">Airframe RPC: Overview</a></li><li><a href="#usage">Usage</a><ul class="toc-headings"><li><a href="#basic-project-structure">Basic Project Structure</a></li><li><a href="#sbt-airframe-plugin">sbt-airframe plugin</a></li><li><a href="#open-api">Open API</a></li><li><a href="#rpc-logging">RPC Logging</a></li><li><a href="#rpc-filters">RPC Filters</a></li><li><a href="#di-integration">DI Integration</a></li><li><a href="#object-serialization">Object Serialization</a></li><li><a href="#receiving-raw-http-responses">Receiving Raw HTTP Responses</a></li><li><a href="#other-tips">Other Tips</a></li></ul></li><li><a href="#airframe-grpc">Airframe gRPC</a><ul class="toc-headings"><li><a href="#starting-airframe-grpc-server">Starting Airframe gRPC Server</a></li></ul></li><li><a href="#rpc-internals">RPC Internals</a><ul class="toc-headings"><li><a href="#rpc-protocol">RPC Protocol</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/airframe/" class="nav-home"><img src="/airframe/img/favicon.ico" alt="Airframe" width="66" height="66"/></a><div><h5>Docs</h5><a href="/airframe/docs/en/index.html">Documentation</a></div><div><h5>Community</h5><a href="https://gitter.im/wvlet/airframe">Gitter Chat</a></div><div><h5>More</h5><a href="https://github.com/wvlet/airframe/">GitHub</a><a class="github-button" href="https://github.com/wvlet/airframe" data-icon="octicon-star" data-count-href="/wvlet/airframe/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://wvlet.org/airframe/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/airframe/img/logos/airframe-badge-dark.png" alt="airframe logo"/></a><section class="copyright">Copyright © 2020 wvlet.org</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.fbAsyncInit = function() {FB.init({appId:'3112325918843547',xfbml:true,version:'v2.7'});};(function(d, s, id){var js, fjs = d.getElementsByTagName(s)[0];if (d.getElementById(id)) {return;}js = d.createElement(s); js.id = id;js.src = '//connect.facebook.net/en_US/sdk.js';fjs.parentNode.insertBefore(js, fjs);}(document, 'script','facebook-jssdk'));
                </script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '71b7e81be03c97dcd37b7a0efc8d6b76',
                indexName: 'airframe',
                inputSelector: '#search_input_react'
              });
            </script></body></html>